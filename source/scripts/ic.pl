############################################################
# ic.pl - generate initial conditions for pmcode(1)
############################################################
#!/usr/bin/perl
use strict;
use warnings;
use autodie;
use Getopt::Long;
use constant PI => 4 * atan2(1, 1);

############################################################
# DEFAULT OPTIONS
############################################################
# Definitions for first few entries in csv row.
my $description = "generated by ic.pl";
my $start_time  = "0.0";
my $end_time    = "1.5e15";
my $timestep    = "1.5e13";
my $iterations  = 0;
my $courant     = "1.0";
my $gravitation = "1.0";
my $light_speed = "1.0";
my $mass        = "1.0";

my $number = 0;                 # Number of particles
# Specify default settings of random cloud.
my $radius = "2000000000.0";    # Maximum radius of placed particles
my $amf = "1.0";                # Angular momentum factor

############################################################
# COMMAND LINE ARGUMENTS
############################################################
# Change any setting given on the command line.
GetOptions ("r|radius=f"             => \$radius,
            "u|amf=f"                => \$amf,
            "n|number=i"             => \$number,
            "d|description=s"        => \$description,
            "s|start-time=f"         => \$start_time,
            "e|end-time=f"           => \$end_time,
            "t|timestep=f"           => \$timestep,
            "i|iterations=f"         => \$iterations,
            "o|courant=f"            => \$courant,
            "g|gravitation=f"        => \$gravitation,
            "c|light-speed=f"        => \$light_speed,
            "m|mass=f"               => \$mass,
            "h|help"                 => \&HELP_MESSAGE)
    or HELP_MESSAGE();

# Print help message for undefined behavior (or --help flag).
sub HELP_MESSAGE {
    print "usage: random_cloud.pl [options]\n";
    print STDERR "\ngenerate random spherical cloud of particles to input into pmcode(1).\n\n";
    print STDERR "  -r | --radius <float>\t\t\tupper bound on particle distance from the origin (default: 2000000000.0)\n";
    print STDERR "  -u | --amf <float>\t\t\tangular momentum factor (default: 1.0)\n";
    print STDERR "  -n | --number <integer>\t\tgenerate <integer> particles (default: [prompts user])\n";
    print STDERR "  --------------------------------------------------------------------------------------\n";
    print STDERR "  -e | --description <string>\t\tdescription of event (default: a cloud of particles generated by random_cloud.pl)\n";
    print STDERR "  -s | --start-time <float>\t\tstart at (physics) time <float> (default: 0.0)\n";
    print STDERR "  -d | --end-time <float>\t\tlength of (physics) time to run code for (default: 1.5e15)\n";
    print STDERR "  -t | --timestep <float>\t\tmaximum length of each timestep (default: 1.5e13)\n";
    print STDERR "  -x | --iterations <integer>\tupper bound on number of iterations (default: 0 = infinity)\n";
    print STDERR "  -o | --courant <float>\t\tcourant number; 1.0 turns adaptive time-stepping off (default: 1.0)\n";
    print STDERR "  -g | --gravitation <float>\t\tgravitational constant (default: 1.0)\n";
    print STDERR "  -c | --light-speed <float>\t\tspeed of light in vacuo (default: 1.0)\n";
    print STDERR "  -m | --mass <float>\t\t\tmass of each particle (default: 1.0)\n";
    exit(1);
}

############################################################
# SETUP
############################################################
# Prompt for number of particles if not specified.
if ($number == 0) {
    print "Enter number of particles: ";
    chomp($number = <STDIN>);
    # Exit if input does not resemble an even integer.
    print "Number of particles must be a positive, even integer value.\n" 
        and exit 0 if not ($number =~ /^\d+$/ and $number % 2 == 0);
    # TODO: allow odd numbers of particles.
}

# Put options into a csv array.
my @row = ($description,',',$start_time,',',$end_time,',',$timestep,',',
    $iterations,',',$courant,',',$gravitation,',',$light_speed);

# Define variables used in the equations below.
my (%position, %momentum);
my (%center_of_mass, %orthogonal, %rotated);

# Routine for calculating the cross product of two vectors.
sub cross_product {
    my @vector = [$1[1]*$2[2] - $1[2]*$2[1],
                  $1[2]*$2[0] - $1[0]*$2[2],
                  $1[0]*$2[1] - $1[1]*$2[0]];
    return @vector;
}

############################################################
# CALCULATIONS
############################################################
foreach (1..$number) {
    # Generate spherical distribution of particles.
    $position{x}[$_] = rand(2 * $radius) - $radius;
    $position{y}[$_] = rand(2 * sqrt($radius^2 - $position{x}[$_]^2)) - sqrt($radius^2 - $position{x}[$_]^2);
    $position{z}[$_] = rand(2 * sqrt($radius^2 - $position{x}[$_]^2 - $position{y}[$_]^2)) - sqrt($radius^2 - $position{x}[$_]^2 - $position{y}[$_]^2);

    # Compute the center of mass.
    $center_of_mass{x} += ($number * $position{x}[$_]);
    $center_of_mass{y} += ($number * $position{y}[$_]);
    $center_of_mass{z} += ($number * $position{z}[$_]);
}

    # Move the center of mass to the origin.
    $position{x} -= $center_of_mass{x};
    $position{y} -= $center_of_mass{y};
    $position{z} -= $center_of_mass{z};

    # Find vector orthogonal to position.
    $orthogonal{x} = $position{y} - $position{z};
    $orthogonal{y} = $position{z} - $position{x};
    $orthogonal{z} = $position{x} - $position{y};

    # Debug checks for whether u is orthogonal to n.
    my @Checks;
    $Checks[0] = $position{x} * $orthogonal{x};
    $Checks[1] = $position{y} * $orthogonal{y};
    $Checks[2] = $position{z} * $orthogonal{z};
    print $Checks[0] + $Checks[1] + $Checks[2] . "\n";

foreach (1..$number) {
    # Generate a random azimuthal angle to rotate through.
    my $random = rand(2 * PI);

    # Use the Rodrigues rotation formula to rotate orthogonal vector through random angle.
    $rotated{x}[$_] = $orthogonal{x}[$_] * cos($random) + ($position{y}[$_]*$orthogonal{z}[$_] - $position{z}[$_]*$orthogonal{y}[$_]) * sin($random);
    $rotated{y}[$_] = $orthogonal{y}[$_] * cos($random) + ($position{z}[$_]*$orthogonal{x}[$_] - $position{x}[$_]*$orthogonal{z}[$_]) * sin($random);
    $rotated{z}[$_] = $orthogonal{z}[$_] * cos($random) + ($position{x}[$_]*$orthogonal{y}[$_] - $position{y}[$_]*$orthogonal{x}[$_]) * sin($random);
}

foreach (1..$number) {
    # Compute corresponding momentum.
    $momentum{x} = ($mass * $orthogonal{x}[$_]);
    $momentum{y} = ($mass * $orthogonal{y}[$_]);
    $momentum{z} = ($mass * $orthogonal{z}[$_]);

    # Add these results to our new csv row.
    push(@row, ',', $mass);
    push(@row, ',', $position{x}[$_], ',', $position{y}[$_], ',', $position{z}[$_]);
    push(@row, ',', $momentum{x}, ',', $momentum{y}, ',', $momentum{z});
}


print @row . "\n";
############################################################
# END ic.pl
############################################################
